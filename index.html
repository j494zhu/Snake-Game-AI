<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Onyx Snake AI - Neural Network Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --accent: #10b981;
            --accent-dark: #059669;
            --danger: #ef4444;
            --warning: #f59e0b;
            --bg-dark: #0f172a;
            --bg-card: #1e293b;
            --bg-hover: #334155;
            --text-primary: #f8fafc;
            --text-secondary: #94a3b8;
            --border: #475569;
            --gold: #fbbf24;
        }
        body {
            background: linear-gradient(135deg, var(--bg-dark) 0%, #1a1a2e 100%);
            color: var(--text-primary);
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        .header h1 {
            font-size: 2.5rem;
            background: linear-gradient(90deg, var(--primary), var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 8px;
        }
        .header p {
            color: var(--text-secondary);
            font-size: 1.1rem;
        }
        .menu-container {
            background: var(--bg-card);
            border-radius: 16px;
            padding: 40px;
            border: 1px solid var(--border);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            max-width: 500px;
            width: 100%;
        }
        .menu-title {
            font-size: 1.5rem;
            margin-bottom: 24px;
            text-align: center;
            color: var(--text-primary);
        }
        .btn {
            display: block;
            width: 100%;
            padding: 16px 24px;
            font-size: 1rem;
            font-weight: 600;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-bottom: 12px;
        }
        .btn-primary {
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            color: white;
        }
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(99, 102, 241, 0.3);
        }
        .btn-accent {
            background: linear-gradient(135deg, var(--accent), var(--accent-dark));
            color: white;
        }
        .btn-accent:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(16, 185, 129, 0.3);
        }
        .btn-secondary {
            background: var(--bg-hover);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }
        .btn-secondary:hover {
            background: var(--border);
        }
        .hidden { display: none !important; }
        
        /* Game Area */
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            width: 100%;
            max-width: 900px;
        }
        .controls-bar {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 16px 24px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 30px;
            width: 100%;
            border: 1px solid var(--border);
            flex-wrap: wrap;
        }
        .speed-control {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .speed-control label {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }
        .speed-slider {
            -webkit-appearance: none;
            width: 150px;
            height: 6px;
            border-radius: 3px;
            background: var(--bg-hover);
            outline: none;
        }
        .speed-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            transition: 0.2s;
        }
        .speed-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }
        .speed-value {
            background: var(--bg-hover);
            padding: 4px 12px;
            border-radius: 6px;
            font-weight: 600;
            min-width: 60px;
            text-align: center;
        }
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--accent);
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .status-dot.error { background: var(--danger); }
        
        .arena-container {
            display: flex;
            flex-direction: row;
            gap: 30px;
            justify-content: center;
            align-items: flex-start;
        }
        .game-panel {
            background: var(--bg-card);
            border-radius: 16px;
            padding: 20px;
            border: 1px solid var(--border);
        }
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }
        .panel-title {
            font-size: 1.1rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .panel-title.ai { color: var(--danger); }
        .panel-title.player { color: var(--accent); }
        .panel-title .icon {
            width: 24px;
            height: 24px;
        }
        .score-display {
            background: var(--bg-hover);
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--gold);
        }
        canvas {
            border-radius: 8px;
            display: block;
        }
        .canvas-ai {
            border: 3px solid var(--danger);
            box-shadow: 0 0 30px rgba(239, 68, 68, 0.2);
        }
        .canvas-player {
            border: 3px solid var(--accent);
            box-shadow: 0 0 30px rgba(16, 185, 129, 0.2);
        }
        .controls-hint {
            text-align: center;
            color: var(--text-secondary);
            font-size: 0.85rem;
            margin-top: 12px;
        }
        .controls-hint kbd {
            background: var(--bg-hover);
            padding: 4px 8px;
            border-radius: 4px;
            font-family: monospace;
            margin: 0 2px;
        }
        
        /* Game Over Overlay */
        .game-over-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 23, 42, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(8px);
        }
        .game-over-card {
            background: var(--bg-card);
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            border: 1px solid var(--border);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            max-width: 400px;
        }
        .game-over-card h2 {
            font-size: 2rem;
            margin-bottom: 16px;
        }
        .game-over-card .final-scores {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 24px 0;
        }
        .final-score-item {
            text-align: center;
        }
        .final-score-item .label {
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-bottom: 4px;
        }
        .final-score-item .value {
            font-size: 2rem;
            font-weight: 700;
        }
        .final-score-item .value.ai { color: var(--danger); }
        .final-score-item .value.player { color: var(--accent); }

        /* Feature badges */
        .features {
            display: flex;
            gap: 12px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        .badge {
            background: var(--bg-hover);
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .badge-icon {
            width: 14px;
            height: 14px;
        }

        /* Countdown Overlay */
        .countdown-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 23, 42, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 999;
            backdrop-filter: blur(4px);
        }
        .countdown-number {
            font-size: 8rem;
            font-weight: 800;
            color: var(--text-primary);
            text-shadow: 0 0 60px var(--primary);
            animation: countdownPulse 1s ease-out;
        }
        .countdown-number.go {
            font-size: 6rem;
            color: var(--accent);
            text-shadow: 0 0 60px var(--accent);
        }
        @keyframes countdownPulse {
            0% {
                transform: scale(1.5);
                opacity: 0;
            }
            50% {
                transform: scale(1);
                opacity: 1;
            }
            100% {
                transform: scale(0.8);
                opacity: 0.5;
            }
        }
    </style>
</head>
<body>

    <div class="header">
        <h1>Onyx Snake AI</h1>
        <p>Deep Reinforcement Learning Demo - Dueling DQN with Rust Backend</p>
    </div>

    <div id="menu" class="menu-container">
        <h2 class="menu-title">Select Game Mode</h2>
        <button class="btn btn-primary" onclick="startGame('demo')">
            <span>Watch AI Demo</span>
        </button>
        <button class="btn btn-accent" onclick="startGame('versus')">
            <span>Play vs AI</span>
        </button>
        <div class="features">
            <span class="badge">
                <svg class="badge-icon" fill="currentColor" viewBox="0 0 20 20"><path d="M13 6a3 3 0 11-6 0 3 3 0 016 0zM18 8a2 2 0 11-4 0 2 2 0 014 0zM14 15a4 4 0 00-8 0v3h8v-3z"/></svg>
                Neural Network
            </span>
            <span class="badge">
                <svg class="badge-icon" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M11.3 1.046A1 1 0 0112 2v5h4a1 1 0 01.82 1.573l-7 10A1 1 0 018 18v-5H4a1 1 0 01-.82-1.573l7-10a1 1 0 011.12-.38z" clip-rule="evenodd"/></svg>
                Rust Powered
            </span>
            <span class="badge">
                <svg class="badge-icon" fill="currentColor" viewBox="0 0 20 20"><path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"/></svg>
                Dueling DQN
            </span>
        </div>
    </div>

    <div id="game-area" class="game-container hidden">
        <div class="controls-bar">
            <div class="speed-control">
                <label for="speedSlider">Speed:</label>
                <input type="range" id="speedSlider" class="speed-slider" min="20" max="500" value="100">
                <span id="speedValue" class="speed-value">100ms</span>
            </div>
            <div class="status-indicator">
                <div id="statusDot" class="status-dot"></div>
                <span id="statusText">AI Connected</span>
            </div>
            <button class="btn btn-secondary" onclick="location.reload()" style="width:auto; margin:0; padding: 10px 20px;">
                Restart
            </button>
        </div>

        <div class="arena-container">
            <div id="player-side" class="game-panel hidden">
                <div class="panel-header">
                    <div class="panel-title player">
                        <svg class="icon" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z" clip-rule="evenodd"/></svg>
                        PLAYER
                    </div>
                    <div class="score-display"><span id="p-score">0</span></div>
                </div>
                <canvas id="playerCanvas" class="canvas-player" width="400" height="400"></canvas>
                <div class="controls-hint">
                    Controls: <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> or <kbd>↑</kbd><kbd>←</kbd><kbd>↓</kbd><kbd>→</kbd>
                </div>
            </div>

            <div id="ai-side" class="game-panel">
                <div class="panel-header">
                    <div class="panel-title ai">
                        <svg class="icon" fill="currentColor" viewBox="0 0 20 20"><path d="M13 7H7v6h6V7z"/><path fill-rule="evenodd" d="M7 2a1 1 0 012 0v1h2V2a1 1 0 112 0v1h2a2 2 0 012 2v2h1a1 1 0 110 2h-1v2h1a1 1 0 110 2h-1v2a2 2 0 01-2 2h-2v1a1 1 0 11-2 0v-1H9v1a1 1 0 11-2 0v-1H5a2 2 0 01-2-2v-2H2a1 1 0 110-2h1V9H2a1 1 0 010-2h1V5a2 2 0 012-2h2V2zM5 5h10v10H5V5z" clip-rule="evenodd"/></svg>
                        ONYX AI v6
                    </div>
                    <div class="score-display"><span id="ai-score">0</span></div>
                </div>
                <canvas id="aiCanvas" class="canvas-ai" width="400" height="400"></canvas>
            </div>
        </div>
    </div>

    <div id="countdown-overlay" class="countdown-overlay hidden">
        <div id="countdown-number" class="countdown-number">3</div>
    </div>

    <div id="game-over-ui" class="game-over-overlay hidden">
        <div class="game-over-card">
            <h2 id="result-text">Game Over</h2>
            <div class="final-scores">
                <div id="player-final-score" class="final-score-item hidden">
                    <div class="label">Player</div>
                    <div class="value player"><span id="p-final">0</span></div>
                </div>
                <div class="final-score-item">
                    <div class="label">AI</div>
                    <div class="value ai"><span id="ai-final">0</span></div>
                </div>
            </div>
            <button class="btn btn-primary" onclick="location.reload()">Play Again</button>
        </div>
    </div>

<script>
const GRID_SIZE = 20;
const CELL_SIZE = 20;
const API_URL = "/predict";

let gameSpeed = 100; // milliseconds per frame
let aiConnected = true;

// Speed slider handler
document.getElementById('speedSlider').addEventListener('input', (e) => {
    gameSpeed = parseInt(e.target.value);
    document.getElementById('speedValue').textContent = gameSpeed + 'ms';
});

class SnakeGame {
    constructor(canvasId, isAI = false) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        this.isAI = isAI;
        this.reset();
    }

    reset() {
        this.snake = [{x: 10, y: 10}, {x: 9, y: 10}, {x: 8, y: 10}];
        this.direction = 0; // 0:Right, 1:Down, 2:Left, 3:Up (matches Rust MOVES)
        this.food = this.placeFood();
        this.score = 0;
        this.done = false;
        this.stepsSinceFood = 0;
    }

    placeFood() {
        let x, y;
        while (true) {
            x = Math.floor(Math.random() * GRID_SIZE);
            y = Math.floor(Math.random() * GRID_SIZE);
            if (!this.snake.some(s => s.x === x && s.y === y)) break;
        }
        return {x, y};
    }

    step(action = 0) {
        if (this.done) return;
        this.stepsSinceFood++;

        // Action: 0:Straight, 1:Right, 2:Left
        if (action === 1) this.direction = (this.direction + 1) % 4;
        else if (action === 2) this.direction = (this.direction + 3) % 4;

        const moves = [[1, 0], [0, 1], [-1, 0], [0, -1]];
        const head = this.snake[0];
        const newHead = { x: head.x + moves[this.direction][0], y: head.y + moves[this.direction][1] };

        // Collision check
        if (newHead.x < 0 || newHead.x >= GRID_SIZE || newHead.y < 0 || newHead.y >= GRID_SIZE ||
            this.snake.some((s, i) => i !== this.snake.length - 1 && s.x === newHead.x && s.y === newHead.y)) {
            this.done = true;
            return;
        }

        this.snake.unshift(newHead);
        if (newHead.x === this.food.x && newHead.y === this.food.y) {
            this.score++;
            this.food = this.placeFood();
            this.stepsSinceFood = 0;
        } else {
            this.snake.pop();
        }

        if (this.stepsSinceFood > 2000) this.done = true;
    }

    // Check if position collides with wall or snake body
    isCollision(x, y) {
        if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return true;
        // Check snake body (excluding tail which will move)
        for (let i = 0; i < this.snake.length - 1; i++) {
            if (this.snake[i].x === x && this.snake[i].y === y) return true;
        }
        return false;
    }

    // Flood fill to count reachable cells (normalized)
    floodFillCount(startX, startY) {
        if (startX < 0 || startX >= GRID_SIZE || startY < 0 || startY >= GRID_SIZE) return 0.0;
        
        const snakeSet = new Set();
        this.snake.forEach(s => snakeSet.add(`${s.x},${s.y}`));
        if (snakeSet.has(`${startX},${startY}`)) return 0.0;
        
        const totalEmpty = GRID_SIZE * GRID_SIZE - this.snake.length;
        if (totalEmpty === 0) return 0.0;
        
        const visited = new Set();
        visited.add(`${startX},${startY}`);
        const queue = [{x: startX, y: startY}];
        let count = 0;
        const moves = [[1, 0], [0, 1], [-1, 0], [0, -1]];
        
        while (queue.length > 0) {
            const {x, y} = queue.shift();
            count++;
            for (const [dx, dy] of moves) {
                const nx = x + dx, ny = y + dy;
                const key = `${nx},${ny}`;
                if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE &&
                    !visited.has(key) && !snakeSet.has(key)) {
                    visited.add(key);
                    queue.push({x: nx, y: ny});
                }
            }
        }
        return count / totalEmpty;
    }

    // Get state matching the Rust implementation
    getState() {
        const spatial = new Array(3).fill(0).map(() => new Array(20).fill(0).map(() => new Array(20).fill(0)));
        const aux = new Array(21).fill(0);
        const moves = [[1, 0], [0, 1], [-1, 0], [0, -1]]; // Right, Down, Left, Up

        const hx = this.snake[0].x;
        const hy = this.snake[0].y;

        // Spatial Channels
        spatial[0][hy][hx] = 1.0; // Head
        this.snake.slice(1).forEach((s, i) => {
            const val = 1.0 - (i / (this.snake.length + 1)) * 0.5;
            spatial[1][s.y][s.x] = val; // Body with gradient
        });
        spatial[2][this.food.y][this.food.x] = 1.0; // Food

        // Aux[0-3]: Direction one-hot
        aux[this.direction] = 1.0;

        // Aux[4-12]: Collision detection at depths 1-3 for forward, right, left
        for (let depth = 1; depth <= 3; depth++) {
            const base = 4 + (depth - 1) * 3;
            // Forward
            const [fdx, fdy] = moves[this.direction];
            aux[base] = this.isCollision(hx + fdx * depth, hy + fdy * depth) ? 1.0 : 0.0;
            // Right
            const rightDir = (this.direction + 1) % 4;
            const [rdx, rdy] = moves[rightDir];
            aux[base + 1] = this.isCollision(hx + rdx * depth, hy + rdy * depth) ? 1.0 : 0.0;
            // Left
            const leftDir = (this.direction + 3) % 4;
            const [ldx, ldy] = moves[leftDir];
            aux[base + 2] = this.isCollision(hx + ldx * depth, hy + ldy * depth) ? 1.0 : 0.0;
        }

        // Aux[13-16]: Food direction relative to head
        const fx = this.food.x, fy = this.food.y;
        aux[13] = fy < hy ? 1.0 : 0.0; // Food is up
        aux[14] = fy > hy ? 1.0 : 0.0; // Food is down
        aux[15] = fx < hx ? 1.0 : 0.0; // Food is left
        aux[16] = fx > hx ? 1.0 : 0.0; // Food is right

        // Aux[17]: Snake length normalized
        aux[17] = this.snake.length / 400.0;

        // Aux[18-20]: Flood fill counts for forward, right, left
        const dirs = [this.direction, (this.direction + 1) % 4, (this.direction + 3) % 4];
        for (let i = 0; i < 3; i++) {
            const [dx, dy] = moves[dirs[i]];
            aux[18 + i] = this.floodFillCount(hx + dx, hy + dy);
        }

        return { spatial, aux };
    }

    draw() {
        const ctx = this.ctx;
        
        // Background
        ctx.fillStyle = "#0f172a";
        ctx.fillRect(0, 0, 400, 400);
        
        // Grid lines (subtle)
        ctx.strokeStyle = "#1e293b";
        ctx.lineWidth = 1;
        for (let i = 0; i <= GRID_SIZE; i++) {
            ctx.beginPath();
            ctx.moveTo(i * CELL_SIZE, 0);
            ctx.lineTo(i * CELL_SIZE, 400);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, i * CELL_SIZE);
            ctx.lineTo(400, i * CELL_SIZE);
            ctx.stroke();
        }

        // Draw food with glow effect
        ctx.shadowColor = "#fbbf24";
        ctx.shadowBlur = 15;
        ctx.fillStyle = "#fbbf24";
        ctx.beginPath();
        ctx.arc(
            this.food.x * CELL_SIZE + CELL_SIZE / 2,
            this.food.y * CELL_SIZE + CELL_SIZE / 2,
            CELL_SIZE / 2 - 2,
            0, Math.PI * 2
        );
        ctx.fill();
        ctx.shadowBlur = 0;

        // Draw snake
        this.snake.forEach((s, i) => {
            const isHead = i === 0;
            if (isHead) {
                ctx.fillStyle = this.isAI ? "#ef4444" : "#10b981";
                ctx.shadowColor = this.isAI ? "#ef4444" : "#10b981";
                ctx.shadowBlur = 10;
            } else {
                const alpha = 1 - (i / this.snake.length) * 0.5;
                ctx.fillStyle = this.isAI ? `rgba(185, 28, 28, ${alpha})` : `rgba(6, 95, 70, ${alpha})`;
                ctx.shadowBlur = 0;
            }
            
            const padding = isHead ? 1 : 2;
            ctx.beginPath();
            ctx.roundRect(
                s.x * CELL_SIZE + padding,
                s.y * CELL_SIZE + padding,
                CELL_SIZE - padding * 2,
                CELL_SIZE - padding * 2,
                isHead ? 6 : 4
            );
            ctx.fill();
        });
        ctx.shadowBlur = 0;
    }
}

let aiGame, playerGame, mode;

function startGame(m) {
    mode = m;
    document.getElementById('menu').classList.add('hidden');
    document.getElementById('game-area').classList.remove('hidden');

    aiGame = new SnakeGame('aiCanvas', true);
    if (mode === 'versus') {
        playerGame = new SnakeGame('playerCanvas', false);
        document.getElementById('player-side').classList.remove('hidden');
        // Show countdown for versus mode
        showCountdown(() => gameLoop());
    } else {
        gameLoop();
    }
}

function showCountdown(callback) {
    const overlay = document.getElementById('countdown-overlay');
    const numberEl = document.getElementById('countdown-number');
    overlay.classList.remove('hidden');
    
    let count = 3;
    numberEl.textContent = count;
    numberEl.className = 'countdown-number';
    
    // Draw initial state
    aiGame.draw();
    playerGame.draw();
    
    const interval = setInterval(() => {
        count--;
        if (count > 0) {
            numberEl.textContent = count;
            numberEl.className = 'countdown-number';
            // Force re-trigger animation
            void numberEl.offsetWidth;
            numberEl.classList.add('countdown-number');
        } else if (count === 0) {
            numberEl.textContent = 'GO!';
            numberEl.className = 'countdown-number go';
        } else {
            clearInterval(interval);
            overlay.classList.add('hidden');
            callback();
        }
    }, 1000);
}

function updateStatus(connected) {
    aiConnected = connected;
    const dot = document.getElementById('statusDot');
    const text = document.getElementById('statusText');
    if (connected) {
        dot.classList.remove('error');
        text.textContent = 'AI Connected';
    } else {
        dot.classList.add('error');
        text.textContent = 'AI Offline';
    }
}

async function gameLoop() {
    // AI decision
    if (!aiGame.done) {
        const state = aiGame.getState();
        try {
            const resp = await fetch(API_URL, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(state)
            });
            const result = await resp.json();
            aiGame.step(result.action);
            updateStatus(true);
        } catch (e) {
            console.error("AI Backend Down");
            updateStatus(false);
            aiGame.step(0); // Continue straight if backend is down
        }
    }

    // Player logic
    if (mode === 'versus' && playerGame && !playerGame.done) {
        playerGame.step(0); // Default: go straight
    }

    // Draw
    aiGame.draw();
    document.getElementById('ai-score').innerText = aiGame.score;
    if (playerGame) {
        playerGame.draw();
        document.getElementById('p-score').innerText = playerGame.score;
    }

    // Check game over
    const aiDone = aiGame.done;
    const playerDone = !playerGame || playerGame.done;

    if ((mode === 'demo' && aiDone) || (mode === 'versus' && aiDone && playerDone)) {
        showGameOver();
        return;
    }
    
    setTimeout(gameLoop, gameSpeed);
}

function showGameOver() {
    document.getElementById('ai-final').innerText = aiGame.score;
    
    if (playerGame) {
        document.getElementById('player-final-score').classList.remove('hidden');
        document.getElementById('p-final').innerText = playerGame.score;
        
        if (playerGame.score > aiGame.score) {
            document.getElementById('result-text').innerText = 'You Win!';
            document.getElementById('result-text').style.color = '#10b981';
        } else if (playerGame.score < aiGame.score) {
            document.getElementById('result-text').innerText = 'AI Wins!';
            document.getElementById('result-text').style.color = '#ef4444';
        } else {
            document.getElementById('result-text').innerText = "It's a Tie!";
            document.getElementById('result-text').style.color = '#fbbf24';
        }
    } else {
        document.getElementById('result-text').innerText = 'Game Over';
    }
    
    document.getElementById('game-over-ui').classList.remove('hidden');
}

// Player controls - ABSOLUTE direction (standard snake controls)
// Press a direction key to move in that direction
window.addEventListener('keydown', e => {
    if (!playerGame || playerGame.done) return;
    
    // Prevent page scrolling with arrow keys
    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
    }
    
    const currentDir = playerGame.direction;
    // Direction mapping: 0:Right, 1:Down, 2:Left, 3:Up
    
    // Go UP (W or Up Arrow) - can't go up if currently going down
    if (e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') {
        if (currentDir !== 1) playerGame.direction = 3;
    }
    // Go DOWN (S or Down Arrow) - can't go down if currently going up
    if (e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') {
        if (currentDir !== 3) playerGame.direction = 1;
    }
    // Go LEFT (A or Left Arrow) - can't go left if currently going right
    if (e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') {
        if (currentDir !== 0) playerGame.direction = 2;
    }
    // Go RIGHT (D or Right Arrow) - can't go right if currently going left
    if (e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') {
        if (currentDir !== 2) playerGame.direction = 0;
    }
});
</script>
</body>
</html>